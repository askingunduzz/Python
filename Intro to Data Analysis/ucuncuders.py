# -*- coding: utf-8 -*-
"""ucuncuDers.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xgynhATdC5HX5pbBvJQFXRdGB4pnuaQB
"""

def function(x:int)-> list:   ##good practice to hint your types
##do sth here
  return None

f = lambda x: x**2    ## f(x)= x**2

def g(x) -> function:   ###function returning another function
  def f(t):  ## decortates the function inside (inner function)
    return t**2 +x
  return f        ##g(2)(3)

##last time he promised to talk about devorator funcitons

import time
from time import time

def time_(g):
  def wrapper(x):
    a=time.time()
    l=g(x)
    b=time.time()
    print(f"This function does its job in {b-a} secs")
    return 1
  return wrapper

@time_
def g(x):
  return x**2   ##x^2

##yok ben yapamadım ders kaydından bul

g(10)    ##NOLUYOO
##In data science we use a lot of decorator functions
##L(g)(x)     L(g)--wrapper function

## you see the decorator functions are a bit hard to deal with, but once you get used to them, they are easy peasy
##ookeey
##Let's get back to our ordinary world!! Let's talk about if statements..

#if something is true:
#  do something
#else
#elif
N=10
if N % 2 == 0:
  print("even")
else:
  print("odd")

if True:
  print("Hello dear!")

if 1:   ##any number other than 0 is ok
  print("yee")

if 0:
  print("ooo")

if -1:
  print("ooo")

if None:      ##printlemez oo
  print("sda1")   ## None is treated as False.

type(None)   ##nonetype AHHAHSA

## Logical statements
x,y,z=True,True,False


if x and y:   ##simple easyyy
  print("Both x and y true")

 ## and, or

if not x:
  print("True -> True")
else:
   print("True -> False")

##Lets talk about the notion of loops(iterators)
##Problem: assume that you are given a list of integers
##you want to find the even integers in this list what
##do you need?
## a for loop, if statement

## x=[1,2,3,4,5,-1,10,100,2]

x=[1,2,3,4,5,-1,10,100,2]
## for loop a bak ASAJASJSA
for i in x:
  ##do whatevs
  if i %2 == 0:
    print(i)      ##çift

a= "My name is abc"
for char in a:
  print(char)

a.__getitem__(3)    ##oooo  the same as a[1]

##break statement!!!!!!
##continue statement!!!!!!!!
##very important for the teacher

for i in range(10):    ##list of numbers to 10:  0,1,2,3,4,...,9
  print(i)

for i in range(1,10,2):    ##o   ## 2:step size
  print(i)

for i in range(100000000000000000000000):
  print(i)
  if i == 10:
    break  ##leave this for loop
  else:
     continue   ##not necessary

L = []
for i in range(100):
  for j in range(100):
    L.append(i*j)
    if i*j == 9:
      print("innermost loop is broken")
      break

len(L)

## Bad habits you should ditch before you learn them,
## like books you should read before you die -> the books you should die before you read them
##habits you should forget before you learn them
a=[1,-1,23,23,12,12]
print(len(a))
print("a")
for i in range(len(a)):
  print(a[i])     ##do not do this!
 ##instead, do this:
for i in a:
  print(i)   ##wayy better

for i,el in enumerate(a):
  print(i,el)   ##no thanks

list(enumerate(a))  ##gives you list of tuples

### zip function
a=[1,2,3,4,-12,23]
b=[12,-12,123,323,3,10,20,-1,3]
for i in range(len(a)):
  print(a[i],b[i])

### zip function
a=[1,2,3,4,-12,23]
b=[12,-12,123,323,3,10]
for a,b in zip(a,b):
  print(a,b)        ##in the case that the lengths of a and b are not the same, short one is considered.

##zip and enumerate hoca çok seviyomuş

## the generators
def f(n,m):
  for i in range(n):
    for j in range(m):
      yield i*j     ##oha ney

f(2,3)

for i in f(3,3):
  print(i)

## the generators
def f(n,m):
  for i in range(1,n+1):
    for j in range(1,m+1):
      yield i*j     ##oha ney

for i in f(2,3):
  print(i)

## the generators
def f(n,m):
  for i in range(1,n+1):
    for j in range(1,m+1):
      yield i*j     ##oha ney

L=f(2,3)

for i in f(2,3):
  print(i)

  ##what is good with generators:
  ##we created it once and run, then the interpreter deletes it dedi hoca
  ##Generators are created once, if you iterate over them once

## An important concept with lists
def f(n:int)->list:
  L=[]    ##hocaya göre this part looks ugly, luckily we have for loops
  for i in range(1,n+1):
    L.append(i**2)
  return L

f(10)    ##list of squares of integers up to 10

[i**2 for i in range(1,11)]          ##list comprehension

##write this function using lambda
f=lambda n : [i**2 for i in range(1,n+1)]
f(10)

##lets just play a game
##HOCANIN GITHUBUNU BUL: Yıldırım Akbal
a= "slm ben şimdi haberleri açtım ordan bi manşey buldum ve haber aldım ama onu yapmaya üşendiğim için ben yazıyorum slm ben şimdi haberleri açtım ordan bi manşey buldum ve h  laber aldım ama onu yapmaya üşendiğim için ben yazıyorum slm ben şimdi haberleri açtım ordan bi man'lşey buldum ve habe..r aldım ama onu yapmaya üşendiğim için ben yazıyorum slm ben şimdi haberleri açtım ordan bi manşey buldum ve haber aldım ama onu yapmaya üşendiğim için ben yazıyorum slm ben şimdi haberleri açtım ordan bi manşey buldum ve haber aldım ama onu yapmaya üşendiğim için ben yazıyorum"

##first question
##How do you find unique characters in this string?
##Motto: keep it stupidly simple
##set kullanırız dedi biri
def return_unique_charc(a:str)->set:
  A=set()
  for char in a:
    A.add(char)
  return A

return_unique_charc(a)  ##whaa

from six import unichr
##Second question
##I would like to find out frequency of characters:
##dictionaries
def return_frqs(a:str)->dict:
  uniq_char=return_unique_charc(a)
  dict_={char :0 for char in uniq_char}
  for char in a:
    dict_[char] += 1
  return dict_
##cleanest one

return_frqs(a)
return_frqs(a).keys()

from six import unichr
##Second question
##I would like to find out frequency of characters:
##dictionaries
def return_frqs(a:str)->dict:
  dict={} #empty dic
  for char in a:
   if char in a.keys():
    dict_[char] +=1
   else:
    dict_[char] =1  ##hoca likes the üst one better

  return dict_
##cleanest one        ##variation without using unique characters

return_frqs(a)    ##ay bilimyorum of

import random
L=[random.randint(-100,100) for i in range(1000) ]

L[:10]    #10tane sayı

##First question
## [-2,1,3,-1] -> [-2,-1,1,3]  sorted this array
##L is an array of integers
##How do we check that this array is sorted?
def check_ifsorted(L:list)->bool:   ##bu method tanımışymış şimdi öğrendim ağ
  N =len(L)
  sorted = True
  for i in range(N-1):
    if L[i]<=L[i+1]:
      continue
    else:
      sorted=False
      break

  return sorted

check_ifsorted([1,2,3,4,5])

type(L)
dir(L)

L.sort()
L

check_ifsorted(L)

L.reverse()
L

L[::-1]

list_=[-1,2,3,4]
list_[1:4]

list_[::-1]   ##CHANGES THE ORDER

from math import inf

2<inf
inf<inf
-inf<inf
-2>-inf

from re import X
from math import inf

###How do we find the minimum element and its argument of an array of floats
## (there may be more than one such elements) pick only one
##en küçüğün kaçıncı yerde olduğunu söylüyo

def min_pick(L:list) -> tuple:
  x=inf
  for val in L:
    if x>val:
    ##  print(x)
      x=val
    ##  print(x)
  return x

min_pick([1,-10,-1,2,4,-40])   ##sonuç doğru

## 5! =5*4*3*2*1
def factorial(n:int)->int:
  i=1
  for j in range(1,n+1):
    i *= j
  return i

factorial(3)

def factorial(n:int):
  if n==1:
    return 1
  return n*factorial(n-1)      ##recursive!

factorial(3)